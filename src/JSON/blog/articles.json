[{"id":"19-10-29-0","title":"react-router4|typescript|webpack4 下的组件按需加载实现和失效问题","labels":["React","webpack"],"created_at":"19-10-29","body":"> 在 react-router4/typescript/webpack4 技术栈下，从头实现组件按需加载\n\n## react-router\n在 webpack [文档](https://webpack.docschina.org/api/module-methods#import-)中这么说的：\n> import('path/to/module') -> Promise\n动态地加载模块。调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。\n\n所以在react-router中，我们常用`react-loadable`实现基于import的路由按需加载配置，like this：\n``` javascript\nimport Loadable from 'react-loadable';\n...\n<Route path=\"/\" exact component={Loadable({\n    component={() => import('@/page/home')}\n})} />} />\n```\n但其实 loadable 的原理很简单，ts下实现一个：\n``` javascript\n\ninterface AsyncComponentModuleType {\n  default: typeof React.Component\n}\n\nexport default (getter: Function) => {\n  return class extends Component<any, {\n    component: null | typeof React.Component\n  }> {\n    constructor(props: any) {\n      super(props);\n      this.state = {\n        component: null\n      };\n    }\n    componentDidMount() {\n      getter().then((res: AsyncComponentModuleType) => {\n        this.setState({\n          component: res.default\n        });\n      });\n    }\n    render() {\n      const C = this.state.component;\n      return C ? <C {...this.props} /> : null;\n    }\n  };\n};\n```\n#### 关于Component的类型\n如果异步回来的component类型指定不对，会报错：\n``` bash\nJSX element type C does not have any construct or call signatures\n```\n也就是 C 的类型不能放在<>中，我们常见的放在<>中的是`JSX.IntrinsicElements`，参见react的index.d.ts。但这是个JSX标签的集合，用在这里虽然能绕过类型检查，但不合理。\n因此我们参考：[What does the error “JSX element type '…' does not have any construct or call signatures” mean?](https://stackoverflow.com/questions/31815633/what-does-the-error-jsx-element-type-does-not-have-any-construct-or-call)\n用`typeof React.Component`。\n\n## webpack4 配置\n#### loader\n如果代码里还有js（不全是ts），在webpack4中要对babelloader进行如下配置，支持js的import打包\n```\npresets: ['@babel/preset-react'],\nplugins: ['@babel/plugin-syntax-dynamic-import']\n```\n#### splitChunks\n在webpack4中splitChunks默认是开启的，不用手动改，当然要深入了解下 splitChunks，可以看这篇：[《一步一步的了解webpack4的splitChunk插件》](https://juejin.im/post/5af1677c6fb9a07ab508dabb)  。\n当然如果已经动了`splitChunks`，需要注意下这个配置\n* chunks：默认是 `async`，配成 `async` 或者 `all`\n\n#### 打包文件名\n`output.chunkFilename`的配置会影响打包产出：\n```\noutput: {\n    chunkFilename: '[name].chunk.js',\n}\n```\n另外`webpack`还支持通过注释指定输出文件名：\n``` javascript\n<Route path=\"/\" exact component={getAsyncComponent(() => import(/* webpackChunkName: 'home' */'@/pages/Home/home'))} />} />\n```\n最终打包出的东西长这样：\n```\nAsset       Size  Chunks                    Chunk Names\nhome.chunk.js  622 bytes   4  [emitted]         p-home\nhome.chunk.css  24.7 KiB   5  [emitted]         p-home\n```\n\n\n## typescript 配置\n> 到这里，前面说的都是废话，因为一搜就能搜到一大把，写这个主要是记录关于ts的配置\n\n其实在配置完上面部分后，我的按需加载是不能用的，实际上虽然任何功能都没受影响，但并没有给我拆包。这块开始没想到是 ts 的问题，查了好多地方。 \n直到我找到这篇博客：[《Code-Splitting a TypeScript Application with import\\(\\) and webpack》](https://mariusschulz.com/blog/code-splitting-a-typescript-application-with-import-and-webpack)\n``` json\n\"module\": \"esnext\",\n\"moduleResolution\": \"node\",\n```\n意思是我们不能给`import`弄死，要按包含`import`模块化方案的语法打包，这样就能声明语法并留着`import`，给`webpack`做分片打包入口用。"}]